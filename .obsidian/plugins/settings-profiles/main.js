/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SettingsProfilesPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/settings/SettingsTab.ts
var import_obsidian3 = require("obsidian");

// src/settings/SettingsInterface.ts
var import_os = require("os");
var import_path = require("path");
var DEFAULT_GLOBAL_SETTINGS = {
  profilesList: []
};
var DEFAULT_VAULT_SETTINGS = {
  profilesPath: (0, import_path.normalize)((0, import_path.join)((0, import_os.homedir)(), "Documents", "Obsidian", "Profiles")),
  activeProfile: {},
  profileUpdate: true,
  profileUpdateDelay: 800,
  uiUpdate: true,
  uiUpdateInterval: 1e3
};
var DEFAULT_PROFILE_OPTIONS = {
  name: "",
  autoSync: true,
  appearance: true,
  app: true,
  bookmarks: true,
  communityPlugins: true,
  communityPluginsAdvanced: {},
  corePlugins: true,
  graph: true,
  hotkeys: true,
  modifiedAt: new Date()
};
var PROFILE_OPTIONS_MAP = {
  name: {
    name: "Name",
    description: "Name of this profile."
  },
  autoSync: {
    name: "Auto-Sync",
    description: "Auto Sync this profile on startup."
  },
  appearance: {
    name: "Appearance",
    description: "Says whether the obsidian appearance settings will sync.",
    file: ["appearance.json", `snippets${import_path.sep}*`, `themes${import_path.sep}*${import_path.sep}*`]
  },
  app: {
    name: "App",
    description: "Says whether the obsidian app settings will sync.",
    file: "app.json"
  },
  bookmarks: {
    name: "Bookmarks",
    description: "Says whether the obsidian bookmarks will sync.",
    file: "bookmarks.json"
  },
  communityPlugins: {
    name: "Community plugins",
    description: "Says whether the community plugins and there settings will sync.",
    file: ["community-plugins.json", `plugins${import_path.sep}*${import_path.sep}*`],
    ignore: `plugins${import_path.sep}settings-profiles${import_path.sep}data.json`
  },
  communityPluginsAdvanced: {
    name: "Community plugins advanced",
    description: "Advanced settings for the community plugins.",
    advanced: "communityPlugins"
  },
  corePlugins: {
    name: "Core plugins",
    description: "Says whether the obsidian core plugin settings will sync.",
    file: ["core-plugins.json", "core-plugins-migration.json"]
  },
  graph: {
    name: "Graph",
    description: "Says whether the obsidian graph settings will sync.",
    file: "graph.json"
  },
  hotkeys: {
    name: "Hotkeys",
    description: "Says whether the obsidian hotkey settings will sync.",
    file: "hotkeys.json"
  },
  modifiedAt: {
    name: "Modified at",
    description: "Date time of last modification."
  }
};

// src/modals/ProfileOptionsModal.ts
var import_obsidian = require("obsidian");
var ProfileOptionsModal = class extends import_obsidian.Modal {
  constructor(app, plugin, profile, onSubmit) {
    super(app);
    this.plugin = plugin;
    this.profile = structuredClone(profile);
    this.initialProfile = structuredClone(profile);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h1", { text: `Profile options` });
    for (const key in this.profile) {
      if (this.profile.hasOwnProperty(key)) {
        const value = this.profile[key];
        if (key === "modifiedAt") {
          break;
        }
        if (typeof value === "boolean" && key !== "enabled") {
          new import_obsidian.Setting(contentEl).setName(PROFILE_OPTIONS_MAP[key].name).setDesc(PROFILE_OPTIONS_MAP[key].description).addToggle((toggle) => toggle.setValue(value).onChange(async (value2) => {
            this.profile[key] = value2;
          }));
        }
        if (typeof value === "string") {
          new import_obsidian.Setting(contentEl).setName(PROFILE_OPTIONS_MAP[key].name).setDesc(PROFILE_OPTIONS_MAP[key].description).addText((text) => text.setPlaceholder(PROFILE_OPTIONS_MAP[key].name).setValue(value).onChange((value2) => {
            this.profile[key] = value2;
          }));
        }
      }
    }
    new import_obsidian.Setting(contentEl).addButton((button) => button.setButtonText("Save").onClick(() => {
      if (this.profile.name === "" || this.profile.name === void 0) {
        new import_obsidian.Notice("Profile name cannot be empty!");
      } else if (this.initialProfile.name !== this.profile.name && this.plugin.getProfilesList().find((profile) => profile.name === this.profile.name)) {
        new import_obsidian.Notice("Profile with this name already exists!");
      } else {
        this.onSubmit(this.profile);
        this.close();
      }
    })).addButton((button) => button.setButtonText("Cancel").setWarning().onClick(() => {
      this.close();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/DialogModal.ts
var import_obsidian2 = require("obsidian");
var DialogModal = class extends import_obsidian2.Modal {
  constructor(app, title, message, onSubmit, onDeny, submit = "Agree", deny = "Cancel") {
    super(app);
    this.titleEl.setText(title);
    this.message = message;
    this.onSubmit = onSubmit;
    this.onDeny = onDeny;
    this.submit = submit;
    this.deny = deny;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("span", { text: this.message });
    new import_obsidian2.Setting(contentEl).addButton((button) => button.setButtonText(this.submit).onClick(() => {
      this.close();
      this.onSubmit();
    })).addButton((button) => button.setButtonText(this.deny).setWarning().onClick(() => {
      this.close();
      this.onDeny();
    })).setClass("modal-buttons");
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/settings/SettingsTab.ts
var import_path2 = require("path");

// src/constants.ts
var ICON_ADD_PROFILE = "plus";
var ICON_RELOAD_PROFILES = "refresh-cw";
var ICON_PROFILE_OPTIONS = "settings";
var ICON_PROFILE_REMOVE = "trash-2";
var ICON_PROFILE_SAVE = "save";
var ICON_CURRENT_PROFILE = "user-check";
var ICON_NOT_CURRENT_PROFILE = "user";
var ICON_NO_CURRENT_PROFILE = "users";
var ICON_UNSAVED_PROFILE = "user-x";
var ICON_UNLOADED_PROFILE = "user-cog";

// src/settings/SettingsTab.ts
var SettingsProfilesSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.plugin.refreshProfilesList();
    new import_obsidian3.Setting(containerEl).setName("Profile save path").setDesc("The path to store the profile settings").addButton((button) => button.setButtonText("Change").setWarning().onClick(() => {
      try {
        const inputEl = this.containerEl.querySelector("#profile-path");
        if (!inputEl) {
          throw Error("Input element not found! #profile-path");
        }
        if (inputEl.value === "") {
          inputEl.value = DEFAULT_VAULT_SETTINGS.profilesPath;
        }
        const backupPath = this.plugin.getProfilesPath();
        this.plugin.setProfilePath(inputEl.value);
        new DialogModal(this.app, "Would you like to change the path to the profiles?", (0, import_path2.isAbsolute)(inputEl.value) ? `Absolut path: ${this.plugin.getAbsolutProfilesPath()}` : `Stores the relative path. Absolut path: ${this.plugin.getAbsolutProfilesPath()} `, () => {
          this.plugin.updateCurrentProfile(void 0);
          this.plugin.setProfilesList([]);
          this.plugin.saveSettings().then(() => {
            this.plugin.refreshProfilesList();
            this.display();
          });
        }, () => {
          this.plugin.setProfilePath(backupPath);
          this.display();
        }).open();
      } catch (e) {
        e.message = "Failed to change profiles path! " + e.message;
        console.error(e);
      }
    }).buttonEl.setAttrs({ "id": "profile-path-change", "style": "visibility:hidden" })).addText((text) => text.setValue(this.plugin.getProfilesPath()).onChange((value) => {
      try {
        const buttonEl = this.containerEl.querySelector("#profile-path-change");
        if (!buttonEl) {
          throw Error("Button element not found! #profile-path-change");
        }
        if (value !== this.plugin.getProfilesPath()) {
          buttonEl.toggleVisibility(true);
        } else {
          buttonEl.toggleVisibility(false);
        }
      } catch (e) {
        e.message = "Failed to change profiles path! " + e.message;
        console.error(e);
      }
    }).inputEl.id = "profile-path");
    new import_obsidian3.Setting(containerEl).setName("UI update").setDesc("Controls UI update, when disabled, fewer file reads/writes are performed").addButton((button) => button.setButtonText("Change").setWarning().onClick(() => {
      try {
        const toggleEl = this.containerEl.querySelector("#ui-update");
        if (!toggleEl) {
          throw Error("Input element not found! #ui-update");
        }
        const backup = this.plugin.getUiUpdate();
        this.plugin.setUiUpdate(toggleEl.hasClass("is-enabled"));
        new DialogModal(this.app, "Reload Obsidian now?", "This is required for changes to take effect.", () => {
          this.plugin.saveSettings().then(() => {
            this.app.commands.executeCommandById("app:reload");
          });
        }, () => {
          this.plugin.setUiUpdate(backup);
          this.display();
        }).open();
      } catch (e) {
        e.message = "Failed to change ui update! " + e.message;
        console.error(e);
      }
    }).buttonEl.setAttrs({ "id": "ui-update-change", "style": "visibility:hidden" })).addToggle((toggle) => toggle.setValue(this.plugin.getUiUpdate()).onChange((value) => {
      try {
        const buttonEl = this.containerEl.querySelector("#ui-update-change");
        if (!buttonEl) {
          throw Error("Button element not found! #ui-update-change");
        }
        if (value !== this.plugin.getUiUpdate()) {
          buttonEl.toggleVisibility(true);
        } else {
          buttonEl.toggleVisibility(false);
        }
      } catch (e) {
        e.message = "Failed to change ui update! " + e.message;
        console.error(e);
      }
    }).toggleEl.setAttr("id", "ui-update"));
    if (this.plugin.getUiUpdate()) {
      new import_obsidian3.Setting(containerEl).setName("UI update interval").setDesc("The time in ms in which ui is updated").addButton((button) => button.setButtonText("Change").setWarning().onClick(() => {
        try {
          const sliderEl = this.containerEl.querySelector("#ui-interval");
          if (!sliderEl) {
            throw Error("Input element not found! #ui-interval");
          }
          const backupInterval = this.plugin.getUiRefreshInterval();
          this.plugin.setUiRefreshInterval(sliderEl.valueAsNumber);
          new DialogModal(this.app, "Reload Obsidian now?", "This is required for changes to take effect.", () => {
            this.plugin.saveSettings().then(() => {
              this.app.commands.executeCommandById("app:reload");
            });
          }, () => {
            this.plugin.setUiRefreshInterval(backupInterval);
            this.display();
          }).open();
        } catch (e) {
          e.message = "Failed to change profile status update interval! " + e.message;
          console.error(e);
        }
      }).buttonEl.setAttrs({ "id": "ui-interval-change", "style": "visibility:hidden" })).addSlider((slider) => slider.setLimits(100, 5e3, 100).setValue(this.plugin.getUiRefreshInterval()).setDynamicTooltip().onChange((value) => {
        try {
          const buttonEl = this.containerEl.querySelector("#ui-interval-change");
          if (!buttonEl) {
            throw Error("Button element not found! #ui-interval-change");
          }
          if (value !== this.plugin.getUiRefreshInterval()) {
            buttonEl.toggleVisibility(true);
          } else {
            buttonEl.toggleVisibility(false);
          }
        } catch (e) {
          e.message = "Failed to change refresh interval! " + e.message;
          console.error(e);
        }
      }).sliderEl.setAttr("id", "ui-interval"));
    }
    new import_obsidian3.Setting(containerEl).setName("Profile update").setDesc("Controls profile update, when disabled, fewer file reads/writes are performed").addButton((button) => button.setButtonText("Change").setWarning().onClick(() => {
      try {
        const toggleEl = this.containerEl.querySelector("#profile-update");
        if (!toggleEl) {
          throw Error("Input element not found! #profile-update");
        }
        const backup = this.plugin.getProfileUpdate();
        this.plugin.setProfileUpdate(toggleEl.hasClass("is-enabled"));
        new DialogModal(this.app, "Reload Obsidian now?", "This is required for changes to take effect.", () => {
          this.plugin.saveSettings().then(() => {
            this.app.commands.executeCommandById("app:reload");
          });
        }, () => {
          this.plugin.setProfileUpdate(backup);
          this.display();
        }).open();
      } catch (e) {
        e.message = "Failed to change profile update! " + e.message;
        console.error(e);
      }
    }).buttonEl.setAttrs({ "id": "profile-update-change", "style": "visibility:hidden" })).addToggle((toggle) => toggle.setValue(this.plugin.getProfileUpdate()).onChange((value) => {
      try {
        const buttonEl = this.containerEl.querySelector("#profile-update-change");
        if (!buttonEl) {
          throw Error("Button element not found! #profile-update-change");
        }
        if (value !== this.plugin.getProfileUpdate()) {
          buttonEl.toggleVisibility(true);
        } else {
          buttonEl.toggleVisibility(false);
        }
      } catch (e) {
        e.message = "Failed to change profile update! " + e.message;
        console.error(e);
      }
    }).toggleEl.setAttr("id", "profile-update"));
    if (this.plugin.getProfileUpdate()) {
      new import_obsidian3.Setting(containerEl).setName("Profile update delay").setDesc("The time in ms that must pass before the profile can be updated again").addButton((button) => button.setButtonText("Change").setWarning().onClick(() => {
        try {
          const sliderEl = this.containerEl.querySelector("#update-delay");
          if (!sliderEl) {
            throw Error("Input element not found! #update-delay");
          }
          const backupDelay = this.plugin.getProfileUpdateDelay();
          this.plugin.setProfileUpdateDelay(sliderEl.valueAsNumber);
          new DialogModal(this.app, "Reload Obsidian now?", "This is required for changes to take effect.", () => {
            this.plugin.saveSettings().then(() => {
              this.app.commands.executeCommandById("app:reload");
            });
          }, () => {
            this.plugin.setProfileUpdateDelay(backupDelay);
            this.display();
          }).open();
        } catch (e) {
          e.message = "Failed to change profile status update interval! " + e.message;
          console.error(e);
        }
      }).buttonEl.setAttrs({ "id": "update-delay-change", "style": "visibility:hidden" })).addSlider((slider) => slider.setLimits(500, 1e4, 250).setValue(this.plugin.getProfileUpdateDelay()).setDynamicTooltip().onChange((value) => {
        try {
          const buttonEl = this.containerEl.querySelector("#update-delay-change");
          if (!buttonEl) {
            throw Error("Button element not found! #update-delay-change");
          }
          if (value !== this.plugin.getProfileUpdateDelay()) {
            buttonEl.toggleVisibility(true);
          } else {
            buttonEl.toggleVisibility(false);
          }
        } catch (e) {
          e.message = "Failed to change refresh interval! " + e.message;
          console.error(e);
        }
      }).sliderEl.setAttr("id", "update-delay"));
    }
    new import_obsidian3.Setting(containerEl).setHeading().setName("Profiles").addExtraButton((button) => button.setIcon(ICON_ADD_PROFILE).setTooltip("Add new profile").onClick(() => {
      new ProfileOptionsModal(this.app, this.plugin, DEFAULT_PROFILE_OPTIONS, async (result) => {
        this.plugin.createProfile(result).then(() => {
          this.display();
        });
      }).open();
    })).addExtraButton((button) => button.setIcon(ICON_RELOAD_PROFILES).setTooltip("Reload profiles").onClick(() => {
      this.plugin.refreshProfilesList();
      this.display();
    }));
    this.plugin.getProfilesList().forEach((profile) => {
      new import_obsidian3.Setting(containerEl.createEl("div", { cls: "profiles-container" })).setName(profile.name).setClass(this.plugin.isEnabled(profile) ? "profile-enabled" : "profile-disabled").addExtraButton((button) => button.setIcon(ICON_PROFILE_OPTIONS).setTooltip("Options").onClick(() => {
        this.plugin.refreshProfilesList();
        const prevName = profile.name;
        new ProfileOptionsModal(this.app, this.plugin, profile, async (result) => {
          this.plugin.editProfile(prevName, result).then(() => {
            this.display();
          });
        }).open();
      })).addExtraButton((button) => button.setIcon(ICON_PROFILE_REMOVE).setTooltip("Remove").onClick(async () => {
        this.plugin.removeProfile(profile.name).then(() => {
          this.display();
        });
      })).addExtraButton((button) => button.setIcon(ICON_PROFILE_SAVE).setTooltip("Save settings to profile").setDisabled(!this.plugin.areSettingsChanged(profile)).onClick(() => {
        new DialogModal(this.app, "Save current settings to profile?", "You are about to overwrite the current settings of this profile. This cannot be undone.", async () => {
          this.plugin.saveProfileSettings(profile).then(() => {
            new import_obsidian3.Notice("Saved profile successfully.");
            this.display();
          });
        }, async () => {
        }, "Override").open();
      })).addExtraButton((button) => button.setIcon(this.plugin.isEnabled(profile) ? ICON_CURRENT_PROFILE : ICON_NOT_CURRENT_PROFILE).setTooltip(this.plugin.isEnabled(profile) ? "Deselect profile" : "Switch to profile").onClick(() => {
        this.plugin.switchProfile(this.plugin.isEnabled(profile) ? "" : profile.name).then(() => {
          this.display();
        });
      }));
    });
  }
};

// src/modals/ProfileSwitcherModal.ts
var import_obsidian4 = require("obsidian");
var ProfileSwitcherModal = class extends import_obsidian4.SuggestModal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
    this.scope.register(["Shift"], "Enter", (evt) => {
      if (!evt.isComposing && this.chooser.useSelectedItem(evt)) {
        return false;
      }
    });
    this.setPlaceholder("Find or create a profile...");
    this.setInstructions([
      {
        command: "\u2191\u2193",
        purpose: "to navigate"
      },
      {
        command: "\u21B5",
        purpose: "to switch"
      },
      {
        command: "shift \u21B5",
        purpose: "to create with options"
      },
      {
        command: "esc",
        purpose: "to dismiss"
      }
    ]);
  }
  // Returns all available suggestions.
  getSuggestions(query) {
    const profiles = this.plugin.getProfilesList().filter(
      (profile) => profile.name.toLowerCase().includes(query.toLowerCase())
    );
    const suggestions = [];
    if (profiles.every((value) => value.name.toLowerCase() !== query.toLowerCase()) && query.length > 0) {
      suggestions.push({
        ...DEFAULT_PROFILE_OPTIONS,
        name: query,
        state: 2 /* NEW */
      });
    }
    profiles.forEach((profile) => {
      suggestions.push({
        ...profile,
        state: this.plugin.isEnabled(profile) ? 1 /* CURRENT */ : 0 /* EXIST */
      });
    });
    return suggestions;
  }
  // Renders each suggestion item.
  renderSuggestion(suggestion, el) {
    var _a, _b;
    el.addClass("mod-complex");
    const content = el.createEl("div", { cls: "suggestion-content" });
    content.createEl("div", { cls: "suggestion-title" }).createEl("span", { text: suggestion.name });
    if (suggestion.state === 2 /* NEW */) {
      (_a = content.parentElement) == null ? void 0 : _a.createEl("div", { cls: "suggestion-aux" }).createEl("span", { text: "Enter to create", cls: "suggestion-hotkey" });
    }
    if (suggestion.state === 1 /* CURRENT */) {
      (_b = content.parentElement) == null ? void 0 : _b.createEl("div", { cls: "suggestion-aux" }).createEl("span", { text: "Current profile", cls: "suggestion-hotkey" });
    }
  }
  // Perform action on the selected suggestion.
  onChooseSuggestion(suggestion, evt) {
    let { state, ...rest } = suggestion;
    const profile = { ...rest };
    if (evt.shiftKey && state !== 0 /* EXIST */ && state !== 1 /* CURRENT */) {
      state = 3 /* NEW_OPTIONS */;
    }
    switch (state) {
      case 2 /* NEW */:
        this.plugin.createProfile(profile).then(() => {
          this.plugin.switchProfile(profile.name);
        });
        break;
      case 3 /* NEW_OPTIONS */:
        new ProfileOptionsModal(this.app, this.plugin, profile, async (result) => {
          this.plugin.createProfile(result).then(() => {
            this.plugin.switchProfile(result.name);
          });
        }).open();
        break;
      case 0 /* EXIST */:
        this.plugin.switchProfile(profile.name);
        break;
    }
    this.close();
  }
};

// src/util/FileSystem.ts
var import_fs = require("fs");
var import_obsidian5 = require("obsidian");
var import_path3 = require("path");
function getAllFiles(path) {
  let pathSections = [];
  let files = [];
  try {
    if ((0, import_path3.join)(...path).includes(`${import_path3.sep}*${import_path3.sep}`)) {
      pathSections = (0, import_path3.join)(...path).split(`${import_path3.sep}*${import_path3.sep}`);
      if (pathSections.length > 0) {
        if (!(0, import_fs.existsSync)(pathSections[0])) {
          console.debug(`The path section does not exist! PathSections: ${pathSections[0]}`);
          return files;
        }
        if (!(0, import_fs.statSync)(pathSections[0]).isDirectory()) {
          console.debug(`The path section is a file and is not inserted, does not match the pattern (/*/)! PathSections: ${pathSections[0]}`);
          return files;
        }
        let pathContent = (0, import_fs.readdirSync)(pathSections[0]);
        pathContent.forEach((value) => {
          const joinedPath = (0, import_path3.join)(pathSections[0], value, ...pathSections.filter((value2, index) => index > 0));
          files = files.concat(getAllFiles([joinedPath]));
        });
      }
    } else if ((0, import_path3.join)(...path).endsWith(`${import_path3.sep}*`)) {
      pathSections = (0, import_path3.join)(...path).split(`${import_path3.sep}*`);
      if (pathSections.length > 0) {
        if (!(0, import_fs.existsSync)(pathSections[0])) {
          console.debug(`The path section does not exist! PathSections: ${pathSections[0]}`);
          return files;
        }
        if (!(0, import_fs.statSync)(pathSections[0]).isDirectory()) {
          console.debug(`The path section is a file and is not inserted, does not match the pattern (/*)! PathSections: ${pathSections[0]}`);
          return files;
        }
        let pathContent = (0, import_fs.readdirSync)(pathSections[0]).map((value) => (0, import_path3.join)(pathSections[0], value));
        files = files.concat(...pathContent.filter((value) => {
          return (0, import_fs.statSync)(value).isFile() && !FILE_IGNORE_LIST.contains((0, import_path3.basename)(value));
        }));
      }
    } else if ((0, import_fs.existsSync)((0, import_path3.join)(...path)) && (0, import_fs.statSync)((0, import_path3.join)(...path)).isFile()) {
      if (!FILE_IGNORE_LIST.contains((0, import_path3.basename)((0, import_path3.join)(...path)))) {
        files.push(...path);
      }
    }
    return files;
  } catch (e) {
    throw e;
  }
}
function copyFile(sourcePath, targetPath) {
  try {
    const sourceFile = (0, import_path3.normalize)((0, import_path3.join)(...sourcePath));
    const targetFile = (0, import_path3.normalize)((0, import_path3.join)(...targetPath));
    if (!isValidPath([sourceFile]) || !(0, import_fs.existsSync)(sourceFile)) {
      throw Error(`Source file does not exist! SourceFile: ${sourceFile}`);
    }
    isValidPath([...targetPath]);
    ensurePathExist([targetFile.slice(0, targetFile.lastIndexOf(import_path3.sep))]);
    if (FILE_IGNORE_LIST.contains((0, import_path3.basename)(sourceFile))) {
      console.warn(`An attempt was made to copy a file that is on the ignore list. File: ${sourceFile}`);
      return;
    }
    (0, import_fs.copyFileSync)(sourceFile, targetFile);
  } catch (e) {
    throw e;
  }
}
function ensurePathExist(path, recursive = true) {
  try {
    if (!(0, import_fs.existsSync)((0, import_path3.join)(...path))) {
      (0, import_fs.mkdirSync)((0, import_path3.join)(...path), { recursive });
      if (!(0, import_fs.existsSync)((0, import_path3.join)(...path))) {
        throw Error(`Could not create path! Path: ${path}`);
      }
    }
  } catch (e) {
    throw e;
  }
}
function isValidPath(path) {
  if ((0, import_path3.join)(...path) === "") {
    return false;
  }
  return true;
}
function removeDirectoryRecursiveSync(path) {
  try {
    const pathS = (0, import_path3.join)(...path);
    if ((0, import_fs.existsSync)(pathS)) {
      if ((0, import_fs.statSync)(pathS).isDirectory()) {
        (0, import_fs.readdirSync)(pathS).forEach((file) => {
          const filePath = (0, import_path3.join)(pathS, file);
          if ((0, import_fs.statSync)(filePath).isDirectory()) {
            removeDirectoryRecursiveSync([filePath]);
          } else {
            (0, import_fs.unlinkSync)(filePath);
          }
        });
        (0, import_fs.rmdirSync)(pathS);
      } else {
        (0, import_fs.rmSync)(pathS);
      }
    }
  } catch (e) {
    throw e;
  }
}
function getVaultPath() {
  const adapter = this.app.vault.adapter;
  if (adapter instanceof import_obsidian5.FileSystemAdapter) {
    return adapter.getBasePath();
  }
  return "";
}
var FILE_IGNORE_LIST = [
  ".DS_Store"
];

// src/util/SettingsFiles.ts
var import_fs2 = require("fs");
var import_path4 = require("path");
async function saveProfileOptions(profile, profilesPath) {
  try {
    if (!profile) {
      throw Error(`Can't save undefined profile! Profile: ${JSON.stringify(profile)}`);
    }
    if (!isValidPath([profilesPath, profile.name])) {
      throw Error(`Invalid path received! ProfilesPath: ${profilesPath}`);
    }
    ensurePathExist([profilesPath, profile.name]);
    const file = (0, import_path4.join)(profilesPath, profile.name, "profile.json");
    const profileSettings = JSON.stringify(profile, null, 2);
    (0, import_fs2.writeFileSync)(file, profileSettings, "utf-8");
  } catch (e) {
    e.message = "Failed to save profile data! " + e.message;
    throw e;
  }
}
function loadProfileOptions(profile, profilesPath) {
  try {
    if (!profile.name) {
      throw Error(`Name is requierd! Profile: ${JSON.stringify(profile)}`);
    }
    const file = (0, import_path4.join)(profilesPath, profile.name, "profile.json");
    let profileData = void 0;
    if (!(0, import_fs2.existsSync)(file)) {
      throw Error(`Path does not exist! Path: ${file}`);
    }
    if (!(0, import_fs2.statSync)(file).isFile()) {
      throw Error(`The path does not point to a file. Path: ${file}`);
    }
    const data = (0, import_fs2.readFileSync)(file, "utf-8");
    profileData = JSON.parse(data);
    if (!profileData) {
      throw Error(`Failed to read profile from file!`);
    }
    profileData.modifiedAt = new Date(profileData.modifiedAt);
    return profileData;
  } catch (e) {
    e.message = "Failed to load profile data! " + e.message;
    throw e;
  }
}
function loadProfilesOptions(profilesPath) {
  try {
    const files = getAllFiles([profilesPath, `${import_path4.sep}*${import_path4.sep}profile.json`]);
    let profilesList = [];
    files.forEach((file) => {
      if (!(0, import_fs2.existsSync)(file)) {
        throw Error(`Path does not exist! Path: ${file}`);
      }
      if (!(0, import_fs2.statSync)(file).isFile()) {
        throw Error(`The path does not point to a file. Path: ${file}`);
      }
      const data = (0, import_fs2.readFileSync)(file, "utf-8");
      let profileData = JSON.parse(data);
      if (!profileData) {
        throw Error(`Failed to read profile from file!`);
      }
      profileData.modifiedAt = new Date(profileData.modifiedAt);
      profilesList.push(profileData);
    });
    return profilesList;
  } catch (e) {
    e.message = "Failed to load profiles data! " + e.message;
    throw e;
  }
}
function getConfigFilesList(profile) {
  var _a;
  const files = [];
  for (const key in profile) {
    if (profile.hasOwnProperty(key)) {
      const value = profile[key];
      if (typeof value === "boolean" && key !== "enabled" && value) {
        const file = (_a = PROFILE_OPTIONS_MAP[key]) == null ? void 0 : _a.file;
        if (file && typeof file === "string") {
          files.push((0, import_path4.normalize)(file));
        } else if (file && Array.isArray(file)) {
          file.forEach((f) => {
            files.push((0, import_path4.normalize)(f));
          });
        }
      }
    }
  }
  return files;
}
function getFilesWithoutPlaceholder(filesList, path) {
  const files = [];
  filesList.forEach((file) => {
    if (file.includes(`${import_path4.sep}*${import_path4.sep}`) || file.includes(`${import_path4.sep}*`)) {
      const pathVariants = getAllFiles([...path, file]).map((value) => value.split(import_path4.sep).slice(-file.split(import_path4.sep).length));
      pathVariants.forEach((value) => {
        files.push((0, import_path4.join)(...value));
      });
    } else {
      files.push(file);
    }
  });
  return files;
}
function getIgnoreFilesList(profile) {
  var _a;
  const files = [];
  for (const key in profile) {
    if (profile.hasOwnProperty(key)) {
      const value = profile[key];
      if (value && typeof value === "boolean") {
        const file = (_a = PROFILE_OPTIONS_MAP[key]) == null ? void 0 : _a.ignore;
        if (file && typeof file === "string") {
          files.push((0, import_path4.normalize)(file));
        } else if (file && Array.isArray(file)) {
          file.forEach((f) => {
            files.push((0, import_path4.normalize)(f));
          });
        }
      }
    }
  }
  return files;
}
function filterIgnoreFilesList(filesList, profile) {
  const ignoreFiles = getIgnoreFilesList(profile);
  return filesList.filter((file) => !ignoreFiles.contains(file));
}
function filterUnchangedFiles(filesList, sourcePath, targetPath) {
  return filesList.filter((file) => {
    const sourceFile = (0, import_path4.join)(...sourcePath, file);
    const targetFile = (0, import_path4.join)(...targetPath, file);
    if (!(0, import_fs2.existsSync)(sourceFile) || !(0, import_fs2.statSync)(sourceFile).isFile()) {
      return false;
    }
    if (!(0, import_fs2.existsSync)(targetFile)) {
      return true;
    }
    if (!(0, import_fs2.statSync)(targetFile).isFile()) {
      return false;
    }
    const sourceData = (0, import_fs2.readFileSync)(sourceFile, "utf-8");
    const targetData = (0, import_fs2.readFileSync)(targetFile, "utf-8");
    return sourceData !== targetData;
  });
}

// src/main.ts
var import_path5 = require("path");
var import_fs3 = require("fs");

// src/core/PluginExtended.ts
var import_obsidian6 = require("obsidian");
var PluginExtended = class extends import_obsidian6.Plugin {
  addStatusBarItem(icon, label, ariaLabel, onClickCallback) {
    const item = super.addStatusBarItem();
    if (icon) {
      const iconWrapper = item.createEl("span", { cls: ["status-bar-item-icon", "status-bar-item-segment"] });
      (0, import_obsidian6.setIcon)(iconWrapper, icon);
    }
    if (label) {
      item.createEl("span", { text: label, cls: ["status-bar-item-label", "status-bar-item-segment"] });
    }
    if (ariaLabel) {
      item.ariaLabel = ariaLabel;
      item.setAttr("data-tooltip-position", "top");
    }
    if (onClickCallback) {
      item.addClass("mod-clickable");
      item.onClickEvent(() => {
        onClickCallback();
      });
    }
    return item;
  }
  updateStatusBarItem(item, icon, label, ariaLabel) {
    if (icon) {
      let iconWrapper = item.getElementsByClassName("status-bar-item-icon")[0];
      if (!iconWrapper) {
        iconWrapper = item.createEl("span", { cls: ["status-bar-item-icon", "status-bar-item-segment"] });
      }
      (0, import_obsidian6.setIcon)(iconWrapper, icon);
    } else {
      let iconWrapper = item.getElementsByClassName("status-bar-item-icon")[0];
      if (iconWrapper) {
        iconWrapper.remove();
      }
    }
    if (label) {
      let labelEl = item.getElementsByClassName("status-bar-item-label")[0];
      if (!labelEl) {
        labelEl = item.createEl("span", { cls: ["status-bar-item-label", "status-bar-item-segment"] });
      }
      labelEl.setText(label);
    } else {
      let labelEl = item.getElementsByClassName("status-bar-item-label")[0];
      if (labelEl) {
        labelEl.remove();
      }
    }
    if (ariaLabel) {
      item.ariaLabel = ariaLabel;
    }
  }
  removeStatusBarItem(item) {
    item.remove();
  }
};

// src/main.ts
var SettingsProfilesPlugin = class extends PluginExtended {
  async onload() {
    await this.loadSettings();
    try {
      ensurePathExist([this.getAbsolutProfilesPath()]);
    } catch (e) {
      new import_obsidian7.Notice("Profile save path is not valid!");
      e.message = "Profile path is not valid! " + e.message;
      console.error(e);
    }
    this.addSettingTab(new SettingsProfilesSettingTab(this.app, this));
    if (this.getProfileUpdate()) {
      this.settingsListener = (0, import_fs3.watch)((0, import_path5.join)(getVaultPath(), this.app.vault.configDir), { recursive: true }, (0, import_obsidian7.debounce)((eventType, filename) => {
        if (eventType !== "change" || !filename)
          return;
        const profile = this.getCurrentProfile();
        if (profile) {
          if (profile.autoSync) {
            this.updateProfile();
          } else if (!getIgnoreFilesList(profile).contains(filename)) {
            profile.modifiedAt = new Date();
            this.updateCurrentProfile(profile);
          }
        }
      }, this.getProfileUpdateDelay(), true));
    }
    if (this.getUiUpdate()) {
      this.updateUI();
      this.registerInterval(window.setInterval(() => {
        this.updateUI();
      }, this.getUiRefreshInterval()));
    }
    this.addCommand({
      id: "open-profile-switcher",
      name: "Open profile switcher",
      callback: () => {
        new ProfileSwitcherModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "current-profile",
      name: "Show current profile",
      callback: () => {
        var _a;
        new import_obsidian7.Notice(`Current profile: ${(_a = this.getCurrentProfile()) == null ? void 0 : _a.name}`);
      }
    });
    this.addCommand({
      id: "save-current-profile",
      name: "Save current profile",
      callback: () => {
        this.refreshProfilesList();
        const profile = this.getCurrentProfile();
        if (profile) {
          this.saveProfileSettings(profile).then(() => {
            new import_obsidian7.Notice("Saved profile successfully.");
          }).catch((e) => {
            new import_obsidian7.Notice("Failed to save profile!");
            e.message = `Failed to handle command! CommandId: save-current-profile Profile: ${profile}` + e.message;
            console.error(e);
          });
        }
      }
    });
    this.addCommand({
      id: "load-current-profile",
      name: "Reload current profile",
      callback: () => {
        this.refreshProfilesList();
        const profile = this.getCurrentProfile();
        if (profile) {
          this.loadProfileSettings(profile).then((profile2) => {
            this.updateCurrentProfile(profile2);
            new DialogModal(this.app, "Reload Obsidian now?", "This is required for changes to take effect.", () => {
              this.saveSettings().then(() => {
                this.app.commands.executeCommandById("app:reload");
              });
            }, () => {
              this.saveSettings();
              new import_obsidian7.Notice("Need to reload obsidian!", 5e3);
            }, "Reload").open();
          });
        }
      }
    });
    this.addCommand({
      id: "update-profile-status",
      name: "Update profile status",
      callback: () => {
        this.updateUI();
      }
    });
  }
  onunload() {
    if (this.settingsListener) {
      this.settingsListener.close();
    }
  }
  /**
   * Update profile save state
   */
  updateProfile() {
    this.refreshProfilesList();
    const profile = this.getCurrentProfile();
    if (profile) {
      if (this.areSettingsChanged(profile)) {
        if (profile.autoSync) {
          this.saveProfileSettings(profile);
        }
      }
    }
  }
  /**
   * Update status bar
   */
  updateUI() {
    let profile = this.getCurrentProfile();
    let icon = ICON_NO_CURRENT_PROFILE;
    let label = "Switch profile";
    if (profile) {
      if (this.isProfileSaved(profile)) {
        if (this.isProfileUpToDate(profile)) {
          icon = ICON_CURRENT_PROFILE;
          label = "Profile up-to-date";
        } else {
          icon = ICON_UNSAVED_PROFILE;
          label = "Unloaded changes for this profile";
        }
      } else {
        icon = ICON_UNLOADED_PROFILE;
        label = "Unsaved changes for this profile";
      }
    }
    if (this.statusBarItem) {
      this.updateStatusBarItem(this.statusBarItem, icon, profile == null ? void 0 : profile.name, label);
    } else {
      this.statusBarItem = this.addStatusBarItem(icon, profile == null ? void 0 : profile.name, label, () => {
        try {
          const profile2 = this.getCurrentProfile();
          if (!profile2 || this.isProfileSaved(profile2)) {
            if (!profile2 || this.isProfileUpToDate(profile2)) {
              new ProfileSwitcherModal(this.app, this).open();
            } else {
              this.loadProfileSettings(profile2).then((profile3) => {
                this.updateCurrentProfile(profile3);
                new DialogModal(this.app, "Reload Obsidian now?", "This is required for changes to take effect.", () => {
                  this.saveSettings().then(() => {
                    this.app.commands.executeCommandById("app:reload");
                  });
                }, () => {
                  this.saveSettings();
                  new import_obsidian7.Notice("Need to reload obsidian!", 5e3);
                }, "Reload").open();
              });
            }
          } else {
            this.saveProfileSettings(profile2).then(() => {
              new import_obsidian7.Notice("Saved profile successfully.");
            });
          }
        } catch (e) {
          e.message = "Failed to handle status bar callback! " + e.message;
          console.error(e);
        }
      });
    }
  }
  /**
   * Load plugin settings from file or default.
   */
  async loadSettings() {
    try {
      this.vaultSettings = Object.assign({}, DEFAULT_VAULT_SETTINGS, await this.loadData());
      this.globalSettings = DEFAULT_GLOBAL_SETTINGS;
      this.refreshProfilesList();
    } catch (e) {
      e.message = "Failed to load settings! " + e.message + ` VaultSettings: ${JSON.stringify(this.vaultSettings)} GlobalSettings: ${JSON.stringify(this.globalSettings)}`;
      console.error(e);
    }
  }
  /**
   * Save plugin vault settings to file.
   */
  async saveSettings() {
    try {
      for (const key in this.vaultSettings) {
        if (!DEFAULT_VAULT_SETTINGS.hasOwnProperty(key)) {
          delete this.vaultSettings[key];
        }
      }
      await this.saveData(this.vaultSettings);
    } catch (e) {
      e.message = "Failed to save settings! " + e.message + ` VaultSettings: ${JSON.stringify(this.vaultSettings)}`;
      console.error(e);
    }
  }
  /**
   * Check relevant files for current profile are changed
   * @returns `ture` if at least one file has changed
   */
  areSettingsChanged(profile) {
    try {
      const sourcePath = [getVaultPath(), this.app.vault.configDir];
      const targetPath = [this.getAbsolutProfilesPath(), profile.name];
      if (!(0, import_fs3.existsSync)((0, import_path5.join)(...sourcePath))) {
        throw Error(`Source path do not exist! SourcePath: ${(0, import_path5.join)(...sourcePath)}`);
      }
      if (!(0, import_fs3.existsSync)((0, import_path5.join)(...targetPath))) {
        return true;
      }
      let filesList = getConfigFilesList(profile);
      filesList = filterIgnoreFilesList(filesList, profile);
      filesList = getFilesWithoutPlaceholder(filesList, sourcePath);
      filesList = filterIgnoreFilesList(filesList, profile);
      filesList = filterUnchangedFiles(filesList, sourcePath, targetPath);
      return filesList.length > 0;
    } catch (e) {
      e.message = "Failed to check settings changed! " + e.message + ` Profile: ${JSON.stringify(profile)}`;
      console.error(e);
      return true;
    }
  }
  /**
   * Load settings and data for the given profile
   * @param profile The profile 
   */
  async loadProfileSettings(profile) {
    try {
      await this.loadProfile(profile.name);
      this.getProfilesList().forEach((value, index, array) => {
        if (value.name === profile.name) {
          array[index] = loadProfileOptions(profile, this.getAbsolutProfilesPath()) || value;
        }
      });
      return this.getProfile(profile.name);
    } catch (e) {
      e.message = "Failed to load profile settings! " + e.message + ` Profile: ${JSON.stringify(profile)} GlobalSettings: ${JSON.stringify(this.globalSettings)}`;
      console.error(e);
    }
  }
  /**
   * Save settings and data for the given profile
   * @param profile The profile 
   */
  async saveProfileSettings(profile) {
    try {
      await this.saveProfile(profile.name);
      await saveProfileOptions(profile, this.getAbsolutProfilesPath());
      this.refreshProfilesList();
      return this.getProfile(profile.name);
    } catch (e) {
      e.message = "Failed to save profile settings! " + e.message + ` Profile: ${JSON.stringify(profile)} GlobalSettings: ${JSON.stringify(this.globalSettings)}`;
      console.error(e);
    }
  }
  /**
   * Switch to other profile with if settings
   * @param profileName The name of the profile to switch to
   */
  async switchProfile(profileName) {
    try {
      this.refreshProfilesList();
      const currentProfile = this.getCurrentProfile();
      if (profileName === "") {
        if (currentProfile) {
          new DialogModal(this.app, "Save befor deselect profile?", "Otherwise, unsaved changes will be lost.", async () => {
            await this.saveProfileSettings(currentProfile);
          }, async () => {
          }, "Save", "Do not Save").open();
        }
        this.updateCurrentProfile(void 0);
        await this.saveSettings();
        return;
      }
      const targetProfile = this.getProfile(profileName);
      if (!targetProfile || !targetProfile.name) {
        throw Error(`Target profile does not exist! TargetProfile: ${JSON.stringify(targetProfile)}`);
      }
      if ((currentProfile == null ? void 0 : currentProfile.name) === targetProfile.name) {
        new import_obsidian7.Notice("Allready current profile!");
        return;
      }
      if (currentProfile == null ? void 0 : currentProfile.autoSync) {
        await this.saveProfileSettings(currentProfile);
      }
      await this.loadProfileSettings(targetProfile).then((profile) => {
        this.updateCurrentProfile(profile);
      });
      new DialogModal(this.app, "Reload Obsidian now?", "This is required for changes to take effect.", () => {
        this.saveSettings().then(() => {
          this.app.commands.executeCommandById("app:reload");
        });
      }, async () => {
        await this.saveSettings();
        new import_obsidian7.Notice("Need to reload obsidian!", 5e3);
      }, "Reload").open();
    } catch (e) {
      this.updateCurrentProfile(void 0);
      new import_obsidian7.Notice(`Failed to switch to ${profileName} profile!`);
      e.message = "Failed to switch profile! " + e.message + ` ProfileName: ${profileName} GlobalSettings: ${JSON.stringify(this.globalSettings)}`;
      console.error(e);
    }
  }
  /**
   * Create a new profile with the current settings 
   * @param profile The profile options the profile should be created with
   */
  async createProfile(profile) {
    try {
      this.appendProfilesList(profile);
      const selectedProfile = this.getProfilesList().find((value) => value.name === profile.name);
      if (selectedProfile) {
        await this.saveProfileSettings(selectedProfile);
      } else {
        await this.removeProfile(profile.name);
        new import_obsidian7.Notice(`Failed to create profile ${profile.name}!`);
      }
    } catch (e) {
      new import_obsidian7.Notice(`Failed to create ${profile.name} profile!`);
      e.message = "Failed to create profile! " + e.message + ` Profile: ${JSON.stringify(profile)} GlobalSettings: ${JSON.stringify(this.globalSettings)}`;
      console.error(e);
    }
  }
  /**
   * Edit the profile with the given profile name to be profileSettings
   * @param profileName The profile name to edit
   * @param profileOptions The new profile options
   */
  async editProfile(profileName, profileOptions) {
    try {
      const profile = this.getProfile(profileName);
      let renamed = false;
      Object.keys(profileOptions).forEach((key) => {
        const objKey = key;
        if (objKey === "name" && profileOptions.name !== profileName) {
          renamed = true;
        }
        const value = profileOptions[objKey];
        if (typeof value === "boolean") {
          profile[objKey] = value;
        }
      });
      if (renamed) {
        await this.createProfile(profileOptions);
        await this.switchProfile(profileOptions.name);
        await this.removeProfile(profileName);
      } else {
        await this.saveProfileSettings(profile);
      }
    } catch (e) {
      new import_obsidian7.Notice(`Failed to edit ${profileName} profile!`);
      e.message = "Failed to edit profile! " + e.message + ` ProfileName: ${profileName} ProfileOptions: ${JSON.stringify(profileOptions)}`;
      console.error(e);
    }
  }
  /**
   * Removes the profile and all its settings
   * @param profileName The name of the profile
   */
  async removeProfile(profileName) {
    try {
      const profile = this.getProfile(profileName);
      if (this.isEnabled(profile)) {
        this.updateCurrentProfile(void 0);
      }
      removeDirectoryRecursiveSync([this.getAbsolutProfilesPath(), profileName]);
      this.refreshProfilesList();
      await this.saveSettings();
    } catch (e) {
      new import_obsidian7.Notice(`Failed to remove ${profileName} profile!`);
      e.message = "Failed to remove profile! " + e.message + ` ProfileName: ${profileName} GlobalSettings: ${JSON.stringify(this.globalSettings)}`;
      console.error(e);
    }
  }
  /**
   * Save the profile settings
   * @param profileName The name of the profile to load.
   * @todo Update profile data/settings only when changed 
   */
  async saveProfile(profileName) {
    try {
      let profile = this.getProfile(profileName);
      const sourcePath = [getVaultPath(), this.app.vault.configDir];
      const targetPath = [this.getAbsolutProfilesPath(), profileName];
      let changed = false;
      ensurePathExist([...targetPath]);
      let filesList = getConfigFilesList(profile);
      filesList = filterIgnoreFilesList(filesList, profile);
      filesList = getFilesWithoutPlaceholder(filesList, sourcePath);
      filesList = filterIgnoreFilesList(filesList, profile);
      filesList = filterUnchangedFiles(filesList, sourcePath, targetPath);
      filesList.forEach((file) => {
        if ((0, import_fs3.existsSync)((0, import_path5.join)(...sourcePath, file))) {
          changed = true;
          copyFile([...sourcePath, file], [...targetPath, file]);
        }
      });
      if (changed) {
        profile.modifiedAt = new Date();
      }
      if (this.isEnabled(profile)) {
        this.updateCurrentProfile(profile);
      }
    } catch (e) {
      new import_obsidian7.Notice(`Failed to save ${profileName} profile!`);
      e.message = "Failed to save profile! " + e.message + ` ProfileName: ${profileName}`;
      console.error(e);
    }
  }
  /**
   * Load the profile settings
   * @param profileName The name of the profile to load.
   */
  async loadProfile(profileName) {
    try {
      const profile = this.getProfile(profileName);
      const sourcePath = [this.getAbsolutProfilesPath(), profileName];
      const targetPath = [getVaultPath(), this.app.vault.configDir];
      if (!(0, import_fs3.existsSync)((0, import_path5.join)(...sourcePath))) {
        throw Error(`Source path do not exist! SourcePath: ${(0, import_path5.join)(...sourcePath)}`);
      }
      let filesList = getConfigFilesList(profile);
      filesList = filterIgnoreFilesList(filesList, profile);
      filesList = getFilesWithoutPlaceholder(filesList, sourcePath);
      filesList = filterIgnoreFilesList(filesList, profile);
      filesList = filterUnchangedFiles(filesList, sourcePath, targetPath);
      filesList.forEach((file) => {
        if ((0, import_fs3.existsSync)((0, import_path5.join)(...sourcePath, file))) {
          copyFile([...sourcePath, file], [...targetPath, file]);
        }
      });
      this.updateCurrentProfile(profile);
    } catch (e) {
      new import_obsidian7.Notice(`Failed to load ${profileName} profile!`);
      e.message = "Failed to load profile! " + e.message + ` ProfileName: ${profileName}`;
      console.error(e);
    }
  }
  /**
   * Returns the path how its saved in settings to profiles. 
   * @returns 
   */
  getProfilesPath() {
    return (0, import_path5.normalize)(this.vaultSettings.profilesPath);
  }
  /**
   * Returns an absolut path to profiles.
   */
  getAbsolutProfilesPath() {
    let path = this.vaultSettings.profilesPath;
    if (!(0, import_path5.isAbsolute)(path)) {
      path = (0, import_path5.join)(getVaultPath(), path);
    }
    if (!isValidPath([path])) {
      throw Error(`No valid profiles path could be found! Path: ${path} ProfilesPath: ${this.vaultSettings.profilesPath}`);
    }
    return (0, import_path5.normalize)(path);
  }
  /**
   * Sets the profiles path in the settings
   * @param path Path the profiles path should be set to
   */
  setProfilePath(path) {
    path = path.trim();
    if (path !== "") {
      this.vaultSettings.profilesPath = (0, import_path5.normalize)(path);
    } else {
      this.vaultSettings.profilesPath = DEFAULT_VAULT_SETTINGS.profilesPath;
    }
  }
  /**
   * Reloads the profiles list from files.
   */
  refreshProfilesList() {
    this.globalSettings.profilesList = loadProfilesOptions(this.getAbsolutProfilesPath());
  }
  /**
   * Appends the profile list with new profile
   * @param profile The profile to add to the profiles list
   */
  appendProfilesList(profile) {
    if (!this.isValidProfile(profile)) {
      throw Error(`No valid profile received! Profile: ${JSON.stringify(profile)}`);
    }
    if (this.getProfilesList().find((p) => profile.name === p.name)) {
      throw Error(`Profile does already exist! Profile: ${JSON.stringify(profile)} ProfilesList: ${JSON.stringify(this.globalSettings.profilesList)}`);
    }
    const length = this.globalSettings.profilesList.length;
    if (length >= this.globalSettings.profilesList.push(profile)) {
      throw Error(`Profile could not be added to the profile list! Profile: ${JSON.stringify(profile)} ProfilesList: ${JSON.stringify(this.globalSettings.profilesList)}`);
    }
  }
  /**
   * Returns the profiles list currently in the settings
   */
  getProfilesList() {
    return this.globalSettings.profilesList;
  }
  /**
   * Set the profiles list in current settings
   * @param profilesList What the profiles list should be set to
   */
  setProfilesList(profilesList) {
    this.globalSettings.profilesList = profilesList;
  }
  /**
   * Returns the refresh interval currently in the settings
   * @returns 
   */
  getUiRefreshInterval() {
    if (!this.vaultSettings.uiUpdateInterval || this.vaultSettings.uiUpdateInterval <= 0 || this.vaultSettings.uiUpdateInterval >= 9e5) {
      this.setUiRefreshInterval(-1);
    }
    return this.vaultSettings.uiUpdateInterval;
  }
  /**
   * Set the refresh interval in current settings
   * @param interval To what the invervall should be set to
   */
  setUiRefreshInterval(interval) {
    if (interval > 0 && interval < 9e5) {
      this.vaultSettings.uiUpdateInterval = interval;
    } else {
      this.vaultSettings.uiUpdateInterval = DEFAULT_VAULT_SETTINGS.uiUpdateInterval;
    }
  }
  getUiUpdate() {
    return this.vaultSettings.uiUpdate;
  }
  setUiUpdate(value) {
    this.vaultSettings.uiUpdate = value;
  }
  getProfileUpdate() {
    return this.vaultSettings.profileUpdate;
  }
  setProfileUpdate(value) {
    this.vaultSettings.profileUpdate = value;
  }
  /**
   * Returns the delay time for profile update currently in the settings
   * @returns 
   */
  getProfileUpdateDelay() {
    if (!this.vaultSettings.profileUpdateDelay || this.vaultSettings.profileUpdateDelay <= 0 || this.vaultSettings.profileUpdateDelay >= 9e5) {
      this.setProfileUpdateDelay(-1);
    }
    return this.vaultSettings.profileUpdateDelay;
  }
  /**
   * Set the delay time for profile update in current settings
   * @param delay To what the invervall should be set to
   */
  setProfileUpdateDelay(delay) {
    if (delay > 100 && delay < 9e5) {
      this.vaultSettings.profileUpdateDelay = delay;
    } else {
      this.vaultSettings.profileUpdateDelay = DEFAULT_VAULT_SETTINGS.profileUpdateDelay;
    }
  }
  /**
   * Gets the profile object
   * @param name The name of the profile
   * @returns The ProfileSetting object. Or undefined if not found.
   */
  getProfile(name) {
    const profile = this.getProfilesList().find((profile2) => profile2.name === name);
    if (!profile) {
      throw Error(`Profile does not exist! ProfileName: ${name} ProfilesList: ${JSON.stringify(this.getProfilesList())}`);
    }
    profile.modifiedAt = new Date(profile.modifiedAt);
    return profile;
  }
  /**
   * Gets the currently enabeled profile.
   * @returns The ProfileSetting object. Or undefined if not found.
   */
  getCurrentProfile() {
    var _a;
    const name = (_a = this.vaultSettings.activeProfile) == null ? void 0 : _a.name;
    if (!name) {
      return;
    }
    const profile = this.getProfilesList().find((profile2) => profile2.name === name);
    if (!profile) {
      return;
    }
    if (this.vaultSettings.activeProfile) {
      let modifiedAt = this.vaultSettings.activeProfile.modifiedAt;
      if (modifiedAt) {
        modifiedAt = new Date(modifiedAt);
        profile.modifiedAt = modifiedAt;
      }
    }
    return profile;
  }
  /**
   * Updates the current profile to passed profile
   * @param profile The profile to update to 
   */
  updateCurrentProfile(profile) {
    if (!profile) {
      this.vaultSettings.activeProfile = {};
      return;
    }
    this.vaultSettings.activeProfile = { name: profile.name, modifiedAt: profile.modifiedAt };
  }
  /**
   * Checks the profile is currently enabled
   * @param profile The profile to check 
   * @returns Is enabled profile
   */
  isEnabled(profile) {
    var _a;
    return ((_a = this.vaultSettings.activeProfile) == null ? void 0 : _a.name) === profile.name;
  }
  /**
   * Checks profile contains all requiered properties
   * @param profile The profile to check
   * @returns True if profile contains all requiered properties
   */
  isValidProfile(profile) {
    let result = true;
    for (const key in DEFAULT_PROFILE_OPTIONS) {
      if (!profile.hasOwnProperty(key)) {
        console.warn(`Missing property in profile! Property: ${key} Profile: ${JSON.stringify(profile)}`);
        result = false;
        break;
      } else if (typeof profile[key] !== typeof DEFAULT_PROFILE_OPTIONS[key]) {
        console.warn(`Wrong type of property in profile! Property: ${key} Type: ${typeof DEFAULT_PROFILE_OPTIONS[key]} Profile: ${JSON.stringify(profile)}`);
        result = false;
        break;
      } else if (profile[key] === void 0 || profile[key] === null) {
        console.warn(`Undefined property in profile! Property: ${key} Profile: ${JSON.stringify(profile)}`);
        result = false;
        break;
      }
    }
    return result;
  }
  /**
   * Checks the profile is up to date to the saved profile
   * @param profile The profile to check 
   * @returns Is loaded profile newer/equal than saved profile
   */
  isProfileUpToDate(profile) {
    const profileData = loadProfileOptions(profile, this.getAbsolutProfilesPath());
    if (!profileData || !profileData.modifiedAt) {
      return false;
    }
    const profileDataDate = new Date(profileData.modifiedAt);
    const profileDate = new Date(profile.modifiedAt);
    return profileDate.getTime() >= profileDataDate.getTime();
  }
  /**
   * Check the profile settings are saved 
   * @param profile The profile to check 
   * @returns Is saved profile newer/equal than saved profile
   */
  isProfileSaved(profile) {
    const profileData = loadProfileOptions(profile, this.getAbsolutProfilesPath());
    if (!profileData || !profileData.modifiedAt) {
      return false;
    }
    const profileDataDate = new Date(profileData.modifiedAt);
    const profileDate = new Date(profile.modifiedAt);
    return profileDate.getTime() <= profileDataDate.getTime();
  }
};
